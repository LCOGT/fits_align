"""
    FITS Align - Align and reproject FITS files from Las Cumbres Observatory
    Copyright (C) 2018 Edward Gomez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from __future__ import absolute_import
from . import star
from . import quad
import os
import numpy as np
from astropy.io import fits

import logging

logger = logging.getLogger(__name__)

class ImgCat:
    """
    Represent an individual image and its associated catalog, starlist, quads etc.
    """

    def __init__(self, filepath, hdu=0, cat=None):
        """

        :param filepath: Path to the FITS file, or alternatively just a string to identify the image.
        :type filepath: string

        :param cat: Catalog generated by SExtractor (if available -- if not, we'll make our own)
        :type cat: asciidata catalog

        :param hdu: The hdu containing the science data from which I should build the catalog. 0 is primary. If multihdu, 1 is usually science.

        """
        self.filepath = filepath

        (imgdir, filename) = os.path.split(filepath)
        (common, ext) = os.path.splitext(filename)
        self.name = common

        self.hdu = hdu
        self.cat = cat
        self.starlist = []
        self.mindist = 0.0
        self.xlim = (0.0, 0.0) # Will be set using the catalog -- no need for the FITS image.
        self.ylim = (0.0, 0.0)

        self.quadlist = []
        self.quadlevel = 0 # encodes what kind of quads have already been computed


    def __str__(self):
        return "%20s: approx %4i x %4i, %4i stars, %4i quads, quadlevel %i" % (os.path.basename(self.filepath),
            self.xlim[1] - self.xlim[0], self.ylim[1] - self.ylim[0],
            len(self.starlist), len(self.quadlist), self.quadlevel)

    def makecat(self, rerun=True, keepcat=False, verbose=True, hdu='CAT'):
        with fits.open(self.filepath) as hdul:
            self.cat = hdul[hdu].data
        return


    def makestarlist(self, skipsaturated=False, n=200, verbose=True):
        # if self.cat:
        if skipsaturated:
            maxflag = 3
        else:
            maxflag = 7
        self.starlist = star.sortstarlistbyflux(star.readsexcat(mycat=self.cat))[:n]
        (xmin, xmax, ymin, ymax) = star.area(self.starlist, border=0.01)
        self.xlim = (xmin, xmax)
        self.ylim = (ymin, ymax)

        # Given this starlists, what is a good minimal distance for stars in quads ?
        self.mindist = min(min(xmax - xmin, ymax - ymin) / 10.0, 30.0)
        #
        # else:
        #     raise RuntimeError("No cat : call makecat first !")


    def makemorequads(self, verbose=True):
        """
        We add more quads, following the quadlevel.
        """
        #if not add:
        #    self.quadlist = []
        logger.debug("Making more quads, from quadlevel %i ..." % self.quadlevel)
        if self.quadlevel == 0:
            self.quadlist.extend(quad.makequads1(self.starlist, n=7, d=self.mindist, verbose=verbose))
        elif self.quadlevel == 1:
            self.quadlist.extend(quad.makequads2(self.starlist, f=3, n=5, d=self.mindist, verbose=verbose))
        elif self.quadlevel == 2:
            self.quadlist.extend(quad.makequads2(self.starlist, f=6, n=5, d=self.mindist, verbose=verbose))
        elif self.quadlevel == 3:
            self.quadlist.extend(quad.makequads2(self.starlist, f=12, n=5, d=self.mindist, verbose=verbose))
        elif self.quadlevel == 4:
            self.quadlist.extend(quad.makequads2(self.starlist, f=10, n=6, s=3, d=self.mindist, verbose=verbose))

        else:
            return False

        self.quadlist = quad.removeduplicates(self.quadlist, verbose=verbose)
        self.quadlevel += 1
        return True



def ccworder(a):
    """
    Sorting a coordinate array CCW to plot polygons ...
    """
    ac = a - np.mean(a, 0)
    indices = np.argsort(np.arctan2(ac[:, 1], ac[:, 0]))
    return a[indices]
